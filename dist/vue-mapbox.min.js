import { computed as e, isRef as t, h as o } from "vue";
import a from "map-promisified";
var i = {
    methods: {
      $_emitEvent(e, t = {}) {
        this.$emit(e, { map: this.map, component: this, ...t });
      },
      $_emitMapEvent(e, t = {}) {
        this.$_emitEvent(e.type, { mapboxEvent: e, ...t });
      }
    }
  },
  s = {
    onResize: { name: "resize", listener: "onResize" },
    onWebglcontextlost: {
      name: "webglcontextlost",
      listener: "onWebglcontextlost"
    },
    onWebglcontextrestored: {
      name: "webglcontextrestored",
      listener: "onWebglcontextrestored"
    },
    onRemove: { name: "remove", listener: "onRemove" },
    onMovestart: { name: "movestart", listener: "onMovestart" },
    onLoad: { name: "load", listener: "onLoad" },
    onContextmenu: { name: "contextmenu", listener: "onContextmenu" },
    onDblclick: { name: "dblclick", listener: "onDblclick" },
    onClick: { name: "click", listener: "onClick" },
    onTouchcancel: { name: "touchcancel", listener: "onTouchcancel" },
    onTouchmove: { name: "touchmove", listener: "onTouchmove" },
    onTouchend: { name: "touchend", listener: "onTouchend" },
    onTouchstart: { name: "touchstart", listener: "onTouchstart" },
    onDataloading: { name: "dataloading", listener: "onDataloading" },
    onMousemove: { name: "mousemove", listener: "onMousemove" },
    onMouseup: { name: "mouseup", listener: "onMouseup" },
    onMousedown: { name: "mousedown", listener: "onMousedown" },
    onSourcedataloading: {
      name: "sourcedataloading",
      listener: "onSourcedataloading"
    },
    onError: { name: "error", listener: "onError" },
    onData: { name: "data", listener: "onData" },
    onStyledata: { name: "styledata", listener: "onStyledata" },
    onSourcedata: { name: "sourcedata", listener: "onSourcedata" },
    onMouseout: { name: "mouseout", listener: "onMouseout" },
    onStyledataloading: {
      name: "styledataloading",
      listener: "onStyledataloading"
    },
    onMoveend: { name: "moveend", listener: "onMoveend" },
    onMove: { name: "move", listener: "onMove" },
    onRender: { name: "render", listener: "onRender" },
    onZoom: { name: "zoom", listener: "onZoom" },
    onZoomstart: { name: "zoomstart", listener: "onZoomstart" },
    onZoomend: { name: "zoomend", listener: "onZoomend" },
    onBoxzoomstart: { name: "boxzoomstart", listener: "onBoxzoomstart" },
    onBoxzoomcancel: { name: "boxzoomcancel", listener: "onBoxzoomcancel" },
    onBoxzoomend: { name: "boxzoomend", listener: "onBoxzoomend" },
    onRotate: { name: "rotate", listener: "onRotate" },
    onRotatestart: { name: "rotatestart", listener: "onRotatestart" },
    onRotateend: { name: "rotateend", listener: "onRotateend" },
    onDragend: { name: "dragend", listener: "onDragend" },
    onDrag: { name: "drag", listener: "onDrag" },
    onDragstart: { name: "dragstart", listener: "onDragstart" },
    onPitch: { name: "pitch", listener: "onPitch" },
    onIdle: { name: "idle", listener: "onIdle" }
  },
  r = {
    container: {
      type: [String, HTMLElement],
      default: () => "map-" + ("" + Math.random()).split(".")[1]
    },
    accessToken: { type: String, default: void 0 },
    minZoom: { type: Number, default: 0 },
    maxZoom: { type: Number, default: 22 },
    mapStyle: { type: [String, Object], required: !0 },
    hash: { type: [Boolean, String], default: !1 },
    interactive: { type: Boolean, default: !0 },
    bearingSnap: { type: Number, default: 7 },
    pitchWithRotate: { type: Boolean, default: !0 },
    clickTolerance: { type: Number, default: 3 },
    attributionControl: { type: Boolean, default: !0 },
    customAttribution: { type: [String, Array], default: null },
    logoPosition: {
      type: String,
      default: "bottom-left",
      validator: e =>
        ["top-left", "top-right", "bottom-left", "bottom-right"].includes(e)
    },
    failIfMajorPerformanceCaveat: { type: Boolean, default: !1 },
    preserveDrawingBuffer: { type: Boolean, default: !1 },
    refreshExpiredTiles: { type: Boolean, default: !0 },
    maxBounds: { type: Array, default() {} },
    scrollZoom: { type: [Boolean, Object], default: () => !0 },
    boxZoom: { type: Boolean, default: !0 },
    dragRotate: { type: Boolean, default: !0 },
    dragPan: { type: Boolean, default: !0 },
    keyboard: { type: Boolean, default: !0 },
    doubleClickZoom: { type: Boolean, default: !0 },
    touchZoomRotate: { type: [Boolean, Object], default: () => !0 },
    trackResize: { type: Boolean, default: !0 },
    center: { type: [Object, Array], default: void 0 },
    zoom: { type: Number, default: 0 },
    bearing: { type: Number, default: 0 },
    pitch: { type: Number, default: 0 },
    bounds: { type: [Object, Array], default: void 0 },
    fitBoundsOptions: { type: Object, default: void 0 },
    renderWorldCopies: { type: Boolean, default: !0 },
    RTLTextPluginUrl: { type: String, default: void 0 },
    light: { type: Object, default: void 0 },
    tileBoundaries: { type: Boolean, default: !1 },
    collisionBoxes: { type: Boolean, default: !1 },
    repaint: { type: Boolean, default: !1 },
    transformRequest: { type: Function, default: null },
    maxTileCacheSize: { type: Number, default: null },
    localIdeographFontFamily: { type: String, default: null },
    collectResourceTiming: { type: Boolean, default: !1 },
    fadeDuration: { type: Number, default: 300 },
    crossSourceCollisions: { type: Boolean, default: !0 }
  },
  n = e => {
    const t = /^on[^a-z]/,
      o = {};
    for (const a in e) t.test(a) && (o[a] = e[a]);
    return o;
  };
const d = {
  maxBounds(e) {
    this.map.setMaxBounds(e);
  },
  minZoom(e) {
    this.map.setMinZoom(e);
  },
  maxZoom(e) {
    this.map.setMaxZoom(e);
  },
  mapStyle(e) {
    this.map.setStyle(e);
  },
  collisionBoxes(e) {
    this.map.showCollisionBoxes = e;
  },
  tileBoundaries(e) {
    this.map.showTileBoundaries = e;
  },
  repaint(e) {
    this.map.repaint = e;
  },
  zoom(e) {
    this.map.setZoom(e);
  },
  center(e) {
    this.map.setCenter(e);
  },
  bearing(e) {
    this.map.setBearing(e);
  },
  pitch(e) {
    this.map.setPitch(e);
  },
  light(e) {
    this.map.setLigh(e);
  }
};
function l(e, t, o, a) {
  if (this.initial) return;
  n(this.$attrs)["onUpdate:" + e]
    ? (this.propsIsUpdating[e]
        ? ((this._watcher.active = !1),
          this.$nextTick(() => {
            this._watcher.active = !0;
          }))
        : ((this._watcher.active = !0), t(o, a)),
      (this.propsIsUpdating[e] = !1))
    : t(o, a);
}
var h = {
    name: "GlMap",
    mixins: [
      {
        watch: (function() {
          const e = {};
          return (
            Object.entries(d).forEach(t => {
              e[t[0]] = function(e, o) {
                return l.call(this, t[0], t[1].bind(this), e, o);
              };
            }),
            e
          );
        })()
      },
      {
        created() {
          this.actions = {};
        },
        methods: {
          $_registerAsyncActions(e) {
            this.actions = {
              ...a(e),
              stop() {
                this.map.stop();
                const e = {
                  pitch: this.map.getPitch(),
                  zoom: this.map.getZoom(),
                  bearing: this.map.getBearing(),
                  center: this.map.getCenter()
                };
                return (
                  Object.entries(e).forEach(e => {
                    this.$_updateSyncedPropsFabric(e[0], e[1])();
                  }),
                  Promise.resolve(e)
                );
              }
            };
          }
        }
      },
      {
        methods: {
          $_updateSyncedPropsFabric(e, t) {
            return () => {
              this.propsIsUpdating[e] = !0;
              let o = "function" == typeof t ? t() : t;
              return this.$emit("update:" + e, o);
            };
          },
          $_bindPropsUpdateEvents() {
            const e = [
                {
                  events: ["moveend"],
                  prop: "center",
                  getter: this.map.getCenter.bind(this.map)
                },
                {
                  events: ["zoomend"],
                  prop: "zoom",
                  getter: this.map.getZoom.bind(this.map)
                },
                {
                  events: ["rotate"],
                  prop: "bearing",
                  getter: this.map.getBearing.bind(this.map)
                },
                {
                  events: ["pitch"],
                  prop: "pitch",
                  getter: this.map.getPitch.bind(this.map)
                },
                {
                  events: ["moveend", "zoomend", "rotate", "pitch"],
                  prop: "bounds",
                  getter: () => {
                    let e = this.map.getBounds();
                    return (
                      this.$props.bounds instanceof Array && (e = e.toArray()),
                      e
                    );
                  }
                }
              ],
              t = n(this.$attrs);
            e.forEach(({ events: e, prop: o, getter: a }) => {
              e.forEach(e => {
                t["onUpdate:" + o] &&
                  this.map.on(e, this.$_updateSyncedPropsFabric(o, a));
              });
            });
          },
          $_loadMap() {
            return this.mapboxPromise.then(
              e => (
                (this.mapbox = e.default ? e.default : e),
                new Promise(e => {
                  this.accessToken &&
                    (this.mapbox.accessToken = this.accessToken);
                  const t = new this.mapbox.Map({
                    ...this._props,
                    container: this.$refs.container,
                    style: this.mapStyle
                  });
                  t.on("load", () => e(t));
                })
              )
            );
          },
          $_RTLTextPluginError(e) {
            this.$emit("rtl-plugin-error", { map: this.map, error: e });
          },
          $_bindMapEvents(e) {
            const t = e.map(e => e.name),
              o = n(this.$attrs);
            Object.keys(o).forEach(e => {
              const o = e.substring(2).toLowerCase();
              t.includes(o) && this.map.on(o, this.$_emitMapEvent);
            });
          },
          $_unbindEvents(e) {
            e.forEach(e => {
              this.map.off(e, this.$_emitMapEvent);
            });
          }
        }
      },
      i
    ],
    props: { mapboxGl: { type: Object, default: null }, ...r },
    provide() {
      return {
        mapbox: e(() => this.mapbox),
        map: e(() => (t(this.map) ? this.map.value : this.map)),
        actions: e(() => this.actions)
      };
    },
    data: () => ({ initial: !0, initialized: !1 }),
    computed: {
      loaded() {
        return !!this.map && this.map.loaded();
      },
      version() {
        return this.map ? this.map.version : null;
      },
      isStyleLoaded() {
        return !!this.map && this.map.isStyleLoaded();
      },
      areTilesLoaded() {
        return !!this.map && this.map.areTilesLoaded();
      },
      isMoving() {
        return !!this.map && this.map.isMoving();
      },
      canvas() {
        return this.map ? this.map.getCanvas() : null;
      },
      canvasContainer() {
        return this.map ? this.map.getCanvasContainer() : null;
      },
      images() {
        return this.map ? this.map.listImages() : null;
      }
    },
    created() {
      (this.map = null),
        (this.propsIsUpdating = {}),
        (this.$_containerVNode = null),
        (this.mapboxPromise = this.mapboxGl
          ? Promise.resolve(this.mapboxGl)
          : import("mapbox-gl"));
    },
    mounted() {
      this.$_loadMap().then(e => {
        (this.map = e),
          void 0 !== this.RTLTextPluginUrl &&
            "loaded" !== this.mapbox.getRTLTextPluginStatus() &&
            this.mapbox.setRTLTextPlugin(
              this.RTLTextPluginUrl,
              this.$_RTLTextPluginError
            );
        const t = Object.values(s);
        this.$_bindMapEvents(t),
          this.$_registerAsyncActions(e),
          this.$_bindPropsUpdateEvents(),
          (this.initial = !1),
          (this.initialized = !0),
          this.$emit("load", { map: e, component: this });
      });
    },
    beforeDestroy() {
      this.$nextTick(() => {
        this.map && this.map.remove();
      });
    },
    render() {
      return (
        this.$$_containerVNode ||
          (this.$_containerVNode = o("div", {
            id: this.container,
            ref: "container"
          })),
        o("div", { class: "mgl-map-wrapper" }, [
          this.$_containerVNode,
          this.initialized ? this.$slots.default() : null
        ])
      );
    }
  },
  u = {
    methods: {
      $_emitSelfEvent(e, t = {}) {
        this.$_emitMapEvent(e, { control: this.control, ...t });
      },
      $_bindSelfEvents(e, t) {
        const o = n(this.$attrs);
        Object.keys(o).forEach(o => {
          const a = o.substring(2).toLowerCase();
          e.includes(a) && t.on(a, this.$_emitSelfEvent);
        });
      },
      $_unbindSelfEvents(e, t) {
        0 !== e.length &&
          t &&
          e.forEach(e => {
            t.off(e, this.$_emitSelfEvent);
          });
      }
    }
  },
  p = {
    mixins: [i, u],
    inject: ["mapbox", "map", "actions"],
    props: { position: { type: String, default: "top-right" } },
    beforeDestroy() {
      this.map && this.control && this.map.value.removeControl(this.control);
    },
    methods: {
      $_addControl() {
        try {
          this.map.value.addControl(this.control, this.position);
        } catch (e) {
          return void this.$_emitEvent("error", { error: e });
        }
        this.$_emitEvent("added", { control: this.control });
      }
    },
    render() {}
  },
  m = {
    name: "NavigationControl",
    mixins: [p],
    props: {
      showCompass: { type: Boolean, default: !0 },
      showZoom: { type: Boolean, default: !0 }
    },
    created() {
      (this.control = new this.mapbox.value.NavigationControl(this.$props)),
        this.$_addControl();
    }
  };
const c = {
  trackuserlocationstart: "trackuserlocationstart",
  trackuserlocationend: "trackuserlocationend",
  geolocate: "geolocate",
  error: "error"
};
var y = {
    name: "GeolocateControl",
    mixins: [i, u, p],
    props: {
      positionOptions: {
        type: Object,
        default: () => ({ enableHighAccuracy: !1, timeout: 6e3 })
      },
      fitBoundsOptions: { type: Object, default: () => ({ maxZoom: 15 }) },
      trackUserLocation: { type: Boolean, default: !1 },
      showUserLocation: { type: Boolean, default: !0 }
    },
    created() {
      const e = this.mapbox.value.GeolocateControl;
      (this.control = new e(this.$props)),
        this.$_addControl(),
        this.$_bindSelfEvents(Object.keys(c), this.control);
    },
    methods: {
      trigger() {
        if (this.control) return this.control.trigger();
      }
    }
  },
  f = {
    name: "FullscreenControl",
    mixins: [p],
    props: { container: { type: HTMLElement, default: void 0 } },
    created() {
      (this.control = new this.mapbox.value.FullscreenControl(this.$props)),
        this.$_addControl();
    }
  },
  v = {
    name: "AttributionControl",
    mixins: [p],
    props: {
      compact: { type: Boolean, default: !0 },
      customAttribution: { type: [String, Array], deafault: void 0 }
    },
    created() {
      (this.control = new this.mapbox.value.AttributionControl(this.$props)),
        this.$_addControl();
    }
  };
const g = { drag: "drag", dragstart: "dragstart", dragend: "dragend" },
  $ = { click: "click", mouseenter: "mouseenter", mouseleave: "mouseleave" };
var b = {
  name: "MapMarker",
  mixins: [i, u],
  inject: ["mapbox", "map"],
  provide() {
    const e = this;
    return {
      get marker() {
        return e.marker;
      }
    };
  },
  props: {
    offset: { type: [Object, Array], default: () => [0, 0] },
    coordinates: { type: Array, required: !0 },
    color: { type: String },
    anchor: { type: String, default: "center" },
    draggable: { type: Boolean, default: !1 }
  },
  data: () => ({ initial: !0, marker: void 0 }),
  watch: {
    coordinates(e) {
      this.initial || this.marker.setLngLat(e);
    },
    draggable(e) {
      this.initial || this.marker.setDraggable(e);
    }
  },
  mounted() {
    const e = { ...this.$props };
    this.$slots.marker && (e.element = this.$slots.marker[0].elm),
      (this.marker = new this.mapbox.value.Marker(e));
    n(this.$attrs)["onUpdate:coordinates"] &&
      this.marker.on("dragend", e => {
        let t;
        (t =
          this.coordinates instanceof Array
            ? [e.target._lngLat.lng, e.target._lngLat.lat]
            : e.target._lngLat),
          this.$emit("update:coordinates", t);
      });
    const t = Object.keys(g);
    this.$_bindSelfEvents(t, this.marker),
      (this.initial = !1),
      this.$_addMarker();
  },
  beforeDestroy() {
    void 0 !== this.map && void 0 !== this.marker && this.marker.remove();
  },
  methods: {
    $_addMarker() {
      this.marker.setLngLat(this.coordinates).addTo(this.map.value),
        this.$_bindMarkerDOMEvents(),
        this.$_emitEvent("added", { marker: this.marker });
    },
    $_emitSelfEvent(e) {
      this.$_emitMapEvent(e, { marker: this.marker });
    },
    $_bindMarkerDOMEvents() {
      const e = n(this.$attrs);
      Object.keys(e).forEach(e => {
        const t = e.substring(2).toLowerCase();
        Object.values($).includes(t) &&
          this.marker._element.addEventListener(t, e => {
            this.$_emitSelfEvent(e);
          });
      });
    },
    remove() {
      this.marker.remove(), this.$_emitEvent("removed");
    },
    togglePopup() {
      return this.marker.togglePopup();
    }
  },
  render() {
    return o("div", { style: { display: "none" } }, [
      this.$slots.marker(),
      this.marker ? this.$slots.default() : null
    ]);
  }
};
const _ = { open: "open", close: "close" };
var S = {
    name: "Popup",
    mixins: [i, u],
    inject: {
      mapbox: { default: null },
      map: { default: null },
      marker: { default: null }
    },
    props: {
      closeButton: { type: Boolean, default: !0 },
      closeOnClick: { type: Boolean, default: !0 },
      anchor: {
        validator: e =>
          "string" == typeof e &&
          [
            "top",
            "bottom",
            "left",
            "right",
            "top-left",
            "top-right",
            "bottom-left",
            "bottom-right"
          ].includes(e),
        default: void 0
      },
      offset: { type: [Number, Object, Array], default: () => [0, 0] },
      coordinates: { type: Array },
      onlyText: { type: Boolean, default: !1 },
      showed: { type: Boolean, default: !1 }
    },
    data: () => ({ initial: !0, popup: void 0 }),
    computed: {
      open: {
        get() {
          return void 0 !== this.popup && this.popup.isOpen();
        },
        set(e) {
          this.map &&
            this.popup &&
            (e ? this.popup.addTo(this.map.value) : this.popup.remove());
        }
      }
    },
    watch: {
      coordinates(e) {
        this.initial || this.popup.setLngLat(e);
      },
      showed(e, t) {
        e !== t && ((this.open = e), this.marker && this.marker.togglePopup());
      }
    },
    created() {
      this.popup = new this.mapbox.value.Popup(this.$props);
    },
    mounted() {
      this.$_addPopup(), (this.initial = !1);
    },
    beforeDestroy() {
      this.map && (this.popup.remove(), this.$_emitEvent("removed"));
    },
    methods: {
      $_addPopup() {
        if (
          ((this.popup = new this.mapbox.value.Popup(this.$props)),
          void 0 !== this.coordinates && this.popup.setLngLat(this.coordinates),
          void 0 !== this.$slots.default)
        )
          if (this.onlyText)
            if (3 === this.$slots.default[0].elm.nodeType) {
              let e = document.createElement("span");
              e.appendChild(this.$slots.default[0].elm),
                this.popup.setText(e.innerText);
            } else this.popup.setText(this.$slots.default[0].elm.innerText);
          else this.popup.setDOMContent(this.$slots.default[0].elm);
        this.$_bindSelfEvents(Object.keys(_), this.popup),
          this.$_emitEvent("added", { popup: this.popup }),
          this.marker && this.marker.setPopup(this.popup),
          this.showed &&
            ((this.open = !0), this.marker && this.marker.togglePopup());
      },
      $_emitSelfEvent(e) {
        this.$_emitMapEvent(e, { popup: this.popup });
      },
      remove() {
        this.popup.remove(), this.$_emitEvent("remove", { popup: this.popup });
      }
    },
    render() {
      return o("div", { style: { display: "none" } }, [this.$slots.default()]);
    }
  },
  I = {
    mousedown: "onMousedown",
    mouseup: "onMouseup",
    click: "onClick",
    dblclick: "onDblclick",
    mousemove: "onMousemove",
    mouseenter: "onMouseenter",
    mouseleave: "onMouseleave",
    mouseover: "onMouseover",
    mouseout: "onMouseout",
    contextmenu: "onContextmenu",
    touchstart: "onTouchstart",
    touchend: "onTouchend",
    touchcancel: "onTouchcancel"
  };
var x = {
  mixins: [i],
  props: {
    ...{
      sourceId: { type: String, required: !0 },
      source: { type: [Object, String], default: void 0 }
    },
    ...{
      layerId: { type: String, required: !0 },
      layer: { type: Object, required: !0 },
      before: { type: String, default: void 0 }
    },
    ...{
      clearSource: { type: Boolean, default: !0 },
      replaceSource: { type: Boolean, default: !1 },
      replace: { type: Boolean, default: !1 }
    }
  },
  inject: ["mapbox", "map"],
  data: () => ({ initial: !0 }),
  computed: {
    sourceLoaded() {
      return !!this.map && this.map.isSourceLoaded(this.sourceId);
    },
    mapLayer() {
      return this.map ? this.map.getLayer(this.layerId) : null;
    },
    mapSource() {
      return this.map ? this.map.getSource(this.sourceId) : null;
    }
  },
  created() {
    this.layer.minzoom &&
      this.$watch("layer.minzoom", function(e) {
        this.initial ||
          this.map.setLayerZoomRange(this.layerId, e, this.layer.maxzoom);
      }),
      this.layer.maxzoom &&
        this.$watch("layer.maxzoom", function(e) {
          this.initial ||
            this.map.setLayerZoomRange(this.layerId, this.layer.minzoom, e);
        }),
      this.layer.paint &&
        this.$watch(
          "layer.paint",
          function(e) {
            if (!this.initial && e)
              for (let t of Object.keys(e))
                this.map.setPaintProperty(this.layerId, t, e[t]);
          },
          { deep: !0 }
        ),
      this.layer.layout &&
        this.$watch(
          "layer.layout",
          function(e) {
            if (!this.initial && e)
              for (let t of Object.keys(e))
                this.map.setLayoutProperty(this.layerId, t, e[t]);
          },
          { deep: !0 }
        ),
      this.layer.filter &&
        this.$watch(
          "layer.filter",
          function(e) {
            this.initial || this.map.setFilter(this.layerId, e);
          },
          { deep: !0 }
        );
  },
  beforeDestroy() {
    if (this.map && this.map.loaded()) {
      try {
        this.map.removeLayer(this.layerId);
      } catch (e) {
        this.$_emitEvent("layer-does-not-exist", {
          layerId: this.sourceId,
          error: e
        });
      }
      if (this.clearSource)
        try {
          this.map.removeSource(this.sourceId);
        } catch (e) {
          this.$_emitEvent("source-does-not-exist", {
            sourceId: this.sourceId,
            error: e
          });
        }
    }
  },
  methods: {
    $_emitLayerMapEvent(e) {
      return this.$_emitMapEvent(e, { layerId: this.layerId });
    },
    $_bindLayerEvents(e) {
      const t = Object.keys(e),
        o = n(this.$attrs);
      Object.keys(o).forEach(e => {
        const o = e.substring(2).toLowerCase();
        t.includes(o) && this.map.on(o, this.layerId, this.$_emitLayerMapEvent);
      });
    },
    $_unbindEvents(e) {
      this.map &&
        e.forEach(e => {
          this.map.off(e, this.layerId, this.$_emitLayerMapEvent);
        });
    },
    $_watchSourceLoading(e) {
      "source" === e.dataType &&
        e.sourceId === this.sourceId &&
        (this.$_emitEvent("layer-source-loading", { sourceId: this.sourceId }),
        this.map.off("dataloading", this.$_watchSourceLoading));
    },
    move(e) {
      this.map.moveLayer(this.layerId, e),
        this.$_emitEvent("layer-moved", { layerId: this.layerId, beforeId: e });
    },
    remove() {
      this.map.removeLayer(this.layerId),
        this.map.removeSource(this.sourceId),
        this.$_emitEvent("layer-removed", { layerId: this.layerId }),
        this.$destroy();
    }
  },
  render() {}
};
const L = i,
  E = u,
  k = p,
  w = x,
  M = { withEvents: i, withSelfEvents: u, asControl: p, asLayer: x },
  C = h,
  B = m,
  T = y,
  P = f,
  j = v,
  O = {
    name: "ScaleControl",
    mixins: [p],
    props: {
      maxWidth: { type: Number, default: 150 },
      unit: {
        type: String,
        default: "metric",
        validator: e => ["imperial", "metric", "nautical"].includes(e)
      }
    },
    watch: {
      unit(e, t) {
        this.control && e !== t && this.control.setUnit(e);
      }
    },
    created() {
      (this.control = new this.mapbox.value.ScaleControl(this.$props)),
        this.$_addControl();
    }
  },
  z = {
    name: "GeojsonLayer",
    mixins: [x],
    computed: {
      getSourceFeatures() {
        return e =>
          this.map
            ? this.map.querySourceFeatures(this.sourceId, { filter: e })
            : null;
      },
      getRenderedFeatures() {
        return (e, t) =>
          this.map
            ? this.map.queryRenderedFeatures(e, {
                layers: [this.layerId],
                filter: t
              })
            : null;
      },
      getClusterExpansionZoom() {
        return e =>
          new Promise((t, o) => {
            if (!this.mapSource)
              return o(
                new Error(`Map source with id ${this.sourceId} not found.`)
              );
            this.mapSource.getClusterExpansionZoom(e, (e, a) =>
              e ? o(e) : t(a)
            );
          });
      },
      getClusterChildren() {
        return e =>
          new Promise((t, o) => {
            const a = this.mapSource;
            if (!a)
              return o(
                new Error(`Map source with id ${this.sourceId} not found.`)
              );
            a.getClusterChildren(e, (e, a) => (e ? o(e) : t(a)));
          });
      },
      getClusterLeaves() {
        return (...e) =>
          new Promise((t, o) => {
            if (!this.mapSource)
              return o(
                new Error(`Map source with id ${this.sourceId} not found.`)
              );
            this.mapSource.getClusterLeaves(...e, (e, a) => (e ? o(e) : t(a)));
          });
      }
    },
    created() {
      this.source &&
        this.$watch(
          "source.data",
          function(e) {
            this.initial || this.mapSource.setData(e);
          },
          { deep: !0 }
        ),
        this.$_deferredMount();
    },
    methods: {
      $_deferredMount() {
        if (
          (this.map.on("dataloading", this.$_watchSourceLoading), this.source)
        ) {
          const e = { type: "geojson", ...this.source };
          try {
            this.map.addSource(this.sourceId, e);
          } catch (t) {
            this.replaceSource &&
              (this.map.removeSource(this.sourceId),
              this.map.addSource(this.sourceId, e));
          }
        }
        this.$_addLayer(),
          this.$_bindLayerEvents(I),
          this.map.off("dataloading", this.$_watchSourceLoading),
          (this.initial = !1);
      },
      $_addLayer() {
        let e = this.map.getLayer(this.layerId);
        if (e) {
          if (!this.replace)
            return (
              this.$_emitEvent("layer-exists", { layerId: this.layerId }), e
            );
          this.map.removeLayer(this.layerId);
        }
        const t = { id: this.layerId, source: this.sourceId, ...this.layer };
        this.map.addLayer(t, this.before),
          this.$_emitEvent("added", { layerId: this.layerId });
      },
      setFeatureState(e, t) {
        if (this.map) {
          const o = { id: e, source: this.source };
          return this.map.setFeatureState(o, t);
        }
      },
      getFeatureState(e) {
        if (this.map) {
          const t = { id: e, source: this.source };
          return this.map.getFeatureState(t);
        }
      },
      removeFeatureState(e, t, o) {
        if (this.map) {
          const a = { id: e, source: this.source, sourceLayer: t };
          return this.map.removeFeatureState(a, o);
        }
      }
    }
  },
  R = {
    name: "ImageLayer",
    mixins: [x],
    created() {
      this.source &&
        (this.source.coordinates &&
          this.$watch(
            "source.coordinates",
            function(e) {
              this.initial || (e && this.mapSource.setCoordinates(e));
            },
            { deep: !0 }
          ),
        this.source.url &&
          this.$watch(
            "source.url",
            function(e) {
              this.initial ||
                (e &&
                  this.mapSource.updateImage({
                    url: e,
                    coordinates: this.source.coordinates
                  }));
            },
            { deep: !0 }
          )),
        this.$_deferredMount();
    },
    methods: {
      $_deferredMount() {
        const e = { type: "image", ...this.source };
        this.map.on("dataloading", this.$_watchSourceLoading);
        try {
          this.map.addSource(this.sourceId, e);
        } catch (t) {
          this.replaceSource &&
            (this.map.removeSource(this.sourceId),
            this.map.addSource(this.sourceId, e));
        }
        this.$_addLayer(), this.$_bindLayerEvents(I), (this.initial = !1);
      },
      $_addLayer() {
        let e = this.map.getLayer(this.layerId);
        if (e) {
          if (!this.replace)
            return (
              this.$_emitEvent("layer-exists", { layerId: this.layerId }), e
            );
          this.map.removeLayer(this.layerId);
        }
        const t = {
          id: this.layerId,
          source: this.sourceId,
          type: "raster",
          ...this.layer
        };
        this.map.addLayer(t, this.before),
          this.$_emitEvent("added", { layerId: this.layerId });
      }
    }
  },
  F = {
    name: "CanvasLayer",
    mixins: [x],
    inject: ["mapbox", "map"],
    props: {
      source: { type: Object, required: !0 },
      layer: { type: Object, default: null }
    },
    computed: {
      canvasElement() {
        return this.mapSource ? this.mapSource.getCanvas() : null;
      }
    },
    watch: {
      coordinates(e) {
        this.initial || this.mapSource.setCoordinates(e);
      }
    },
    created() {
      this.$_deferredMount();
    },
    methods: {
      $_deferredMount() {
        const e = { type: "canvas", ...this.source };
        this.map.on("dataloading", this.$_watchSourceLoading);
        try {
          this.map.addSource(this.sourceId, e);
        } catch (t) {
          this.replaceSource &&
            (this.map.removeSource(this.sourceId),
            this.map.addSource(this.sourceId, e));
        }
        this.$_addLayer(), this.$_bindLayerEvents(I), (this.initial = !1);
      },
      $_addLayer() {
        let e = this.map.getLayer(this.layerId);
        if (e) {
          if (!this.replace)
            return (
              this.$_emitEvent("layer-exists", { layerId: this.layerId }), e
            );
          this.map.removeLayer(this.layerId);
        }
        let t = {
          id: this.layerId,
          source: this.sourceId,
          type: "raster",
          ...this.layer
        };
        this.map.addLayer(t, this.before),
          this.$_emitEvent("added", {
            layerId: this.layerId,
            canvas: this.canvasElement
          });
      }
    }
  },
  D = {
    name: "VideoLayer",
    mixins: [x],
    computed: {
      video() {
        return this.map.getSource(this.sourceId).getVideo();
      }
    },
    created() {
      this.source &&
        this.source.coordinates &&
        this.$watch("source.coordinates", function(e) {
          this.initial || this.mapSource.setCoordinates(e);
        }),
        this.$_deferredMount();
    },
    methods: {
      $_deferredMount() {
        const e = { type: "video", ...this.source };
        this.map.on("dataloading", this.$_watchSourceLoading);
        try {
          this.map.addSource(this.sourceId, e);
        } catch (t) {
          this.replaceSource &&
            (this.map.removeSource(this.sourceId),
            this.map.addSource(this.sourceId, e));
        }
        this.$_addLayer(), this.$_bindLayerEvents(I), (this.initial = !1);
      },
      $_addLayer() {
        let e = this.map.getLayer(this.layerId);
        if (e) {
          if (!this.replace)
            return (
              this.$_emitEvent("layer-exists", { layerId: this.layerId }), e
            );
          this.map.removeLayer(this.layerId);
        }
        let t = {
          id: this.layerId,
          source: this.sourceId,
          type: "background",
          ...this.layer
        };
        this.map.addLayer(t, this.before),
          this.$_emitEvent("added", { layerId: this.layerId });
      }
    }
  },
  Z = {
    name: "VectorLayer",
    mixins: [x],
    computed: {
      getSourceFeatures() {
        return e =>
          this.map
            ? this.map.value.querySourceFeatures(this.sourceId, {
                sourceLayer: this.layer["source-layer"],
                filter: e
              })
            : null;
      },
      getRenderedFeatures() {
        return (e, t) =>
          this.map
            ? this.map.value.queryRenderedFeatures(e, {
                layers: [this.layerId],
                filter: t
              })
            : null;
      }
    },
    watch: {
      filter(e) {
        this.initial || this.map.value.setFilter(this.layerId, e);
      }
    },
    created() {
      this.$_deferredMount();
    },
    methods: {
      $_deferredMount() {
        let e = { type: "vector", ...this.source };
        this.map.value.on("dataloading", this.$_watchSourceLoading);
        try {
          this.map.value.addSource(this.sourceId, e);
        } catch (t) {
          this.replaceSource &&
            (this.map.value.removeSource(this.sourceId),
            this.map.value.addSource(this.sourceId, e));
        }
        this.$_addLayer(),
          this.$_bindLayerEvents(I),
          this.map.value.off("dataloading", this.$_watchSourceLoading),
          (this.initial = !1);
      },
      $_addLayer() {
        let e = this.map.value.getLayer(this.layerId);
        if (e) {
          if (!this.replace)
            return (
              this.$_emitEvent("layer-exists", { layerId: this.layerId }), e
            );
          this.map.value.removeLayer(this.layerId);
        }
        let t = { id: this.layerId, source: this.sourceId, ...this.layer };
        this.map.value.addLayer(t, this.before),
          this.$_emitEvent("added", { layerId: this.layerId });
      },
      setFeatureState(e, t) {
        if (this.map) {
          const o = {
            id: e,
            source: this.sourceId,
            "source-layer": this.layer["source-layer"]
          };
          return this.map.value.setFeatureState(o, t);
        }
      },
      getFeatureState(e) {
        if (this.map) {
          const t = {
            id: e,
            source: this.source,
            "source-layer": this.layer["source-layer"]
          };
          return this.map.value.getFeatureState(t);
        }
      }
    }
  },
  A = {
    name: "RasterLayer",
    mixins: [x],
    created() {
      this.$_deferredMount();
    },
    methods: {
      $_deferredMount() {
        let e = { type: "raster", ...this.source };
        this.map.on("dataloading", this.$_watchSourceLoading);
        try {
          this.map.addSource(this.sourceId, e);
        } catch (t) {
          this.replaceSource &&
            (this.map.removeSource(this.sourceId),
            this.map.addSource(this.sourceId, e));
        }
        this.$_addLayer(),
          this.$_bindLayerEvents(I),
          this.map.off("dataloading", this.$_watchSourceLoading),
          (this.initial = !1);
      },
      $_addLayer() {
        let e = this.map.getLayer(this.layerId);
        if (e) {
          if (!this.replace)
            return (
              this.$_emitEvent("layer-exists", { layerId: this.layerId }), e
            );
          this.map.removeLayer(this.layerId);
        }
        let t = {
          id: this.layerId,
          type: "raster",
          source: this.sourceId,
          ...this.layer
        };
        this.map.addLayer(t, this.before),
          this.$_emitEvent("added", { layerId: this.layerId });
      }
    }
  },
  N = b,
  U = S;
export {
  M as $helpers,
  j as MglAttributionControl,
  F as MglCanvasLayer,
  P as MglFullscreenControl,
  z as MglGeojsonLayer,
  T as MglGeolocateControl,
  R as MglImageLayer,
  C as MglMap,
  N as MglMarker,
  B as MglNavigationControl,
  U as MglPopup,
  A as MglRasterLayer,
  O as MglScaleControl,
  Z as MglVectorLayer,
  D as MglVideoLayer,
  k as asControl,
  w as asLayer,
  L as withEvents,
  E as withSelfEvents
};
